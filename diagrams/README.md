# AGV Software Overview

## 1. System Overview

Our AGV software architecture was built from the ground up to be a
modular, state-driven control system designed for robustness, simple
debugging, and ease of extension as more components were added. The
architecture separates high-level competition logic from navigation,
motion control, sensing, and grabber related subsystems.

The software as required runs on MicroPython and describes each physical
aspect of the robot strongly using standard OOP techniques. We employ
asynchronous execution, primarily through state driven handlers,
alongside periodic hardware timer interrupts for time critical sensor
updates.

## 2. Architectural Structure

The software is organised into the following primary modules:

-   Main Entry (main.py)

    -   Entry point for the robot which waits for button activation
        before launching the competition logic control loop.

-   High level competition logic (overallnavigation.py)

    -   Implements the high-level AGV state machine governing pickup,
        dropoff, navigation routing, LED feedback, and sensor inputs.

-   Navigation Subsystem

    -   Responsible for route path planning, junction handling,
        line-following, and relative orientation management. It employs
        BFS-based pathfinding, motion command generation of an entire
        route from pathfinding result using virtual orientation, and
        uses a PD controller for continuous line correction.

```{=html}
<!-- -->
```
-   Grabber Subsystem

    -   Controls the jaw and lifter servos and performs resistance
        sensing to identify reel types. This component operates through
        clearly defined state machines for pickup and dropoff sequences.

-   Sensor Modules

    -   Includes line sensors with moving average filtering,
        Time-of-Flight (ToF) sensors for bay occupancy detection, and
        button debounce logic.

-   Logging and Configuration

    -   Centralised configuration files define PD coefficients, timing
        constants, directed node graph of the arena, and physical GPIO
        pin assignments. A custom high performance logger with
        configurable log levels, and both file based and USB debugging
        modes gave us easy insights into the robot's logic and made it
        simpler to find logical errors. It also was built such that we
        could disable it during the competition, instead returning a
        ProtoLogger that dramatically improves performance.

## 3. State Machine Design

The AGV operates using hierarchical finite state machines (FSMs). At the
highest level, the AGV in the overallnavigation handler transitions
through the AGV states REST, MOVING_TO_PICKUP, PICKING_UP,
MOVING_TO_DROPOFF, DROPPING_OFF, and ENDING_RUN.

Within these macro states, given components maintain independent
sub-state machines. For example, navigation distinguishes between route
traversal, junction handling, and dropoff navigation. The grabber
subsystem manages servo transitions and resistance sensing using its own
state definitions and handlers.

## 4. Control and Timing Strategy

A periodic hardware timer schedules critical sensor updates, interrupts
(button) & control updates using deferred execution via micropython's
schedule method at a fixed frequency.

The asynchronous main loop performs high-level logic transitions and
handles longer-duration operations such as navigation route following
and high level pickup / dropoff.

## 5. Modularity and Maintainability

All classes and functions include structured docstrings describing
purpose, arguments, and return values. Configuration constants were
centralised to avoid magic numbers. Subsystems communicate through
well-defined state interfaces.

## 6. Conclusion

We think that the software architecture and implementation is / was
designed to be clear, structured, and extensible. We intentionally built
the system from the ground up using hierarchical & nested state
machines, modular subsystem separation, and extensive inline
documentation through docstrings and comments. It allowed us to quickly
add new higher / adjacent component layers as required, building on
previous layers (I.E basic motion control to navigation to pathfinding,
and then later the grabber and surrounding components and logic) without
having to modify the existing lower layers. It also made debugging and
finding logical errors in our FSM implementations simple, particularly
through analysing the state transitions / events generated by the
logger.
